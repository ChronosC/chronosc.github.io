# 算法：计算一个数的下个为2的幂的数

## 介绍

输入一个值，计算出一个比它大的为2的幂的数。

## 思路
所有为2的幂的数，它的二进制数表示永远只有一位为1，其它都是为0
* 2º：00000001
* 2¹：00000010
* 2²：00000100
* 2³：00001000
* ...


## 代码

```
int nextPowerOf2(int n) {
    n -= 1;
    n |= n >>> 16;
    n |= n >>> 8;
    n |= n >>> 4;
    n |= n >>> 2;
    n |= n >>> 1;
    return n + 1;
}
```

目的是把`n - 1`从最高位为1的位开始到最低位的所有位全都变成`1`，最后加`1`进位，以达到目的。

> 注：如果`n`本身已经是2的幂，只运行移位就会得到`n * 2`，所以先减1。如果`n`是0，减1就是-1，对应的无符号数为位数全为1的数，加1结果是0。

## 附 - 判断一个数是否为2的幂

### 算法1

> 所有为2的幂的数，它的二进制数表示永远只有一位为`1`，其它都是为`0`，将这个数减去`1`后，仅有的那个`1`会变为`0`，而原来的那n个`0`会变为`1`。如原来的数`'n'`为`00100000`，`'n-1'`为`00011111`。因此，将原来的数与减去1后的数字进行与运算后为零。

```
public static boolean isPowerOf2(int n) {
    return (n & n - 1) == 0;
}
```

### 算法2
> 所有为2的幂的数，它的二进制数表示永远只有一位为`1`，其它都是为`0`，这个数的补码是`1`位位置前面的位全部变为`1`，`1`位位置后面的位全部变为`0`。如原来的数`'n'`为`00100000`，`'-n'`为`11100000`。因此，将原来的数与原来的数的补码进行与运算后为原来的数不变。
```
public static boolean isPowerOf2(int n) {
    return (n & -n) == n;
}
```

